
<!DOCTYPE html>


<html lang="en" data-content_root="../" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>translate_app.md &#8212; My sample book</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../_static/styles/theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="../_static/styles/bootstrap.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="../_static/styles/pydata-sphinx-theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />

  
  <link href="../_static/vendor/fontawesome/6.5.2/css/all.min.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.5.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.5.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.5.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=03e43079" />
    <link rel="stylesheet" type="text/css" href="../_static/styles/sphinx-book-theme.css?v=eba8b062" />
    <link rel="stylesheet" type="text/css" href="../_static/togglebutton.css?v=13237357" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css?v=76b2166b" />
    <link rel="stylesheet" type="text/css" href="../_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-thebe.css?v=4fa983c6" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-design.min.css?v=95c83b7e" />
    <link rel="stylesheet" type="text/css" href="https://unpkg.com/thebe@latest/lib/index.css" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b" />
<link rel="preload" as="script" href="../_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b" />
  <script src="../_static/vendor/fontawesome/6.5.2/js/all.min.js?digest=dfe6caa3a7d634c4db9b"></script>

    <script src="../_static/documentation_options.js?v=9eb32ce0"></script>
    <script src="../_static/doctools.js?v=9a2dae69"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/clipboard.min.js?v=a7894cd8"></script>
    <script src="../_static/copybutton.js?v=f281be69"></script>
    <script src="../_static/scripts/sphinx-book-theme.js?v=887ef09a"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="../_static/togglebutton.js?v=4a39c7ea"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="../_static/design-tabs.js?v=f930bc37"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"; const thebe_selector = ".thebe,.cell"; const thebe_selector_input = "pre"; const thebe_selector_output = ".output, .cell_output"</script>
    <script async="async" src="../_static/sphinx-thebe.js?v=c100c467"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"; const thebe_selector = ".thebe,.cell"; const thebe_selector_input = "pre"; const thebe_selector_output = ".output, .cell_output"</script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'pages/app';</script>
    <script src="https://unpkg.com/thebe@latest/lib/index.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="prev" title="Welcome to your Jupyter Book" href="../intro.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">Skip to main content</a></div>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>Back to top</button>

  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-primary-sidebar-checkbox"/>
  <label class="overlay overlay-primary" for="pst-primary-sidebar-checkbox"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-secondary-sidebar-checkbox"/>
  <label class="overlay overlay-secondary" for="pst-secondary-sidebar-checkbox"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search this book..."
         aria-label="Search this book..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="Version warning"></aside>
</div>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">

  
    
  

<a class="navbar-brand logo" href="../intro.html">
  
  
  
  
  
    
    
      
    
    
    <img src="../_static/logo.png" class="logo__image only-light" alt="My sample book - Home"/>
    <script>document.write(`<img src="../_static/logo.png" class="logo__image only-dark" alt="My sample book - Home"/>`);</script>
  
  
</a></div>
        <div class="sidebar-primary-item">

 <script>
 document.write(`
   <button class="btn search-button-field search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
    <span class="search-button__default-text">Search</span>
    <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
   </button>
 `);
 </script></div>
        <div class="sidebar-primary-item"><nav class="bd-links bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        
        <ul class="nav bd-sidenav bd-sidenav__home-link">
            <li class="toctree-l1">
                <a class="reference internal" href="../intro.html">
                    Welcome to your Jupyter Book
                </a>
            </li>
        </ul>
        <ul class="current nav bd-sidenav">
<li class="toctree-l1 current active"><a class="current reference internal" href="#">軟體介紹</a></li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><button class="sidebar-toggle primary-toggle btn btn-sm" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</button></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">





<div class="dropdown dropdown-download-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Download this page">
    <i class="fas fa-download"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="../_sources/pages/app.md" target="_blank"
   class="btn btn-sm btn-download-source-button dropdown-item"
   title="Download source file"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="btn__text-container">.md</span>
</a>
</li>
      
      
      
      
      <li>
<button onclick="window.print()"
  class="btn btn-sm btn-download-pdf-button dropdown-item"
  title="Print to PDF"
  data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="btn__text-container">.pdf</span>
</button>
</li>
      
  </ul>
</div>




<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="Fullscreen mode"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>



<script>
document.write(`
  <button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="theme-switch fa-solid fa-sun fa-lg" data-mode="light"></i>
    <i class="theme-switch fa-solid fa-moon fa-lg" data-mode="dark"></i>
    <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"></i>
  </button>
`);
</script>


<script>
document.write(`
  <button class="btn btn-sm pst-navbar-icon search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass fa-lg"></i>
  </button>
`);
</script>

</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1>translate_app.md</h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <hr/>
<section id="translate-app-md">
<h1><code class="docutils literal notranslate"><span class="pre">translate_app.md</span></code><a class="headerlink" href="#translate-app-md" title="Link to this heading">#</a></h1>
<div class="highlight-markdown notranslate"><div class="highlight"><pre><span></span><span class="gh"># TS Translator App</span>

<span class="k">&gt; </span><span class="ge">按上方的 **⚡️ Live Code** 啟動互動模式（Thebe）。</span>

&lt;hr/&gt;

<span class="gu">## 1) 原始碼（翻譯引擎）</span>

```{code-cell} ipython3
:tags: [hide-output]

<span class="gh"># -*- coding: utf-8 -*-</span>
&quot;&quot;&quot;
Qt .ts 翻譯（OpenAI ChatGPT API + LCS 詞彙提示 + HTML/佔位符遮罩保留）
強化版：去重、併發多批、批次 JSON 輸出、進度條（支援 widgets 回呼）
&quot;&quot;&quot;
import os, re, glob, html, json, time, random, shutil
from typing import List, Tuple, Dict, Optional, Callable
from concurrent.futures import ThreadPoolExecutor, as_completed

import pandas as pd
import xml.etree.ElementTree as ET

try:
    from tqdm.auto import tqdm  # CLI fallback
except Exception:
    class _NoTQDM:
        def <span class="gs">__init__</span>(self, total=None, desc=None, unit=None): pass
        def update(self, n=1): pass
        def close(self): pass
    def tqdm(*args, **kwargs):
        return _NoTQDM()

from openai import OpenAI

<span class="gh"># ================== 工具：讀 DOCTYPE ==================</span>
def <span class="ge">_read_</span>doctype(xml_text: str) -&gt; str:
    m = re.search(r&#39;&lt;!DOCTYPE[^&gt;]+&gt;&#39;, xml_text)
    return m.group(0) if m else &quot;&quot;

<span class="gh"># ================== 讀 ODS 詞庫（若無則空表） ==================</span>
def load_lookup_from_ods(folder: str = &quot;data&quot;) -&gt; pd.DataFrame:
    paths = sorted(glob.glob(os.path.join(folder, &quot;*.ods&quot;)))
    if not paths:
        # 線上環境常無 ODS，回傳空表即可
        print(f&quot;[提示] 詞庫資料夾 {folder} 無 .ods；將在無 glossary 模式下運作。&quot;)
        return pd.DataFrame({&quot;en&quot;: [], &quot;zh&quot;: []})
    rows = []
    for p in paths:
        try:
            df = pd.read_excel(p, engine=&quot;odf&quot;)
            if &quot;英文名稱&quot; in df.columns and &quot;中文名稱&quot; in df.columns:
                sub = df[[&quot;英文名稱&quot;, &quot;中文名稱&quot;]].copy()
                sub.columns = [&quot;en&quot;, &quot;zh&quot;]
                rows.append(sub)
            else:
                print(f&quot;[略過] {p} 缺少『英文名稱/中文名稱』欄位&quot;)
        except Exception as e:
            print(f&quot;[警告] 無法讀取 {p}: {e}&quot;)
    if not rows:
        print(&quot;[提示] 找不到可用的詞庫欄位，改為空表。&quot;)
        return pd.DataFrame({&quot;en&quot;: [], &quot;zh&quot;: []})

    tbl = pd.concat(rows, ignore_index=True)
    tbl[&quot;en&quot;] = tbl[&quot;en&quot;].astype(str).str.strip()
    tbl[&quot;zh&quot;] = tbl[&quot;zh&quot;].astype(str).str.strip()
    tbl = tbl.dropna(subset=[&quot;en&quot;, &quot;zh&quot;])
    tbl = tbl[(tbl[&quot;en&quot;] != &quot;&quot;) &amp; (tbl[&quot;zh&quot;] != &quot;&quot;)]
    tbl = tbl.drop_duplicates(subset=[&quot;en&quot;], keep=&quot;first&quot;).reset_index(drop=True)
    return tbl

<span class="gh"># ================== LCS 比對工具 ==================</span>
def normalize_token(s: str) -&gt; str: return s.lower()
def normalize_cand(s: str) -&gt; str:  return s.lower()

def anchored_prefix_sub_in(token_norm: str, cand_norm: str) -&gt; Tuple[int, str]:
    if not token_norm or not cand_norm:
        return 0, &quot;&quot;
    max_k = min(len(token_norm), len(cand_norm))
    for k in range(max_k, 0, -1):
        sub = token_norm[:k]
        if sub in cand_norm:
            return k, sub
    return 0, &quot;&quot;

<span class="ge">_SEP_</span>RE = re.compile(r&#39;[\s/_\-.]+&#39;)
def soft_norm(s: str) -&gt; str:
    return <span class="ge">_SEP_</span>RE.sub(&#39; &#39;, s.lower()).strip()

<span class="ge">_GLOSSARY_</span>FILTER_PAT = re.compile(
    r&#39;(&#39;
    r&#39;&lt;/?[A-Za-z][^&gt;]*&gt;&#39;
    r&#39;|&amp;lt;/?[A-Za-z][^&amp;]*?&amp;gt;&#39;
    r&#39;|%L\d+&#39;
    r&#39;|%\d+&#39;
    r&#39;|%n&#39;
    r&#39;|\{\d+\}&#39;
    r&#39;|&amp;(?:[A-Za-z]+|#\d+|#x[0-9A-Fa-f]+);&#39;
    r&#39;)&#39;,
    flags=re.IGNORECASE
)
def <span class="ge">_clean_</span>for_glossary(text: str) -&gt; str:
    return <span class="ge">_GLOSSARY_</span>FILTER_PAT.sub(&#39; &#39;, text)

class LCSMatcher:
    <span class="ge">_TOKEN_</span>RE = re.compile(r&quot;[A-Za-z0-9]+(?:[\/_.-][A-Za-z0-9]+)*&quot;)

    def <span class="gs">__init__</span>(self, lookup_df: pd.DataFrame, min_token_len: int = 4, min_lcs_len: int = 4):
        self.lookup = lookup_df.copy()
        self.lookup[&quot;en_norm&quot;] = self.lookup[&quot;en&quot;].apply(normalize_cand) if len(self.lookup) else []
        if len(self.lookup):
            self.lookup = self.lookup[self.lookup[&quot;en_norm&quot;].str.len() &gt;= 1].reset_index(drop=True)
            self.lookup[&quot;charset&quot;] = self.lookup[&quot;en_norm&quot;].apply(lambda s: set(re.sub(r&quot;\s+&quot;, &quot;&quot;, s)))
            self.lookup[&quot;en_soft&quot;] = self.lookup[&quot;en&quot;].apply(soft_norm)
            self.soft_index: Dict[str, Tuple[str, str]] = {}
            for _, row in self.lookup.iterrows():
                key = row[&quot;en_soft&quot;]
                if key not in self.soft_index:
                    self.soft_index[key] = (row[&quot;en&quot;], row[&quot;zh&quot;])
            self.max_soft_len = max((len(x.split()) for x in self.lookup[&quot;en_soft&quot;]), default=1)
        else:
            self.lookup = pd.DataFrame({&quot;en&quot;: [], &quot;zh&quot;: [], &quot;en_norm&quot;: []})
            self.soft_index = {}
            self.max_soft_len = 1
        self.min_token_len = min_token_len
        self.min_lcs_len = min_lcs_len

    def <span class="ge">_topk_</span>for_word(self, token: str, k: int = 3) -&gt; List[Dict]:
        if len(self.lookup) == 0:
            return []
        t<span class="ge">_norm = normalize_</span>token(token)
        if len(t_norm) &lt; self.min_token_len:
            return []
        t<span class="ge">_chars = set(t_</span>norm)
        candidates = self.lookup[self.lookup[&quot;charset&quot;].apply(lambda s: len(s &amp; t_chars) &gt; 0)]
        results = []
        for _, row in candidates.iterrows():
            kk, sub = anchored_prefix_sub_in(t_norm, row[&quot;en_norm&quot;])
            if kk &gt;= self.min_lcs_len:
                results.append({
                    &quot;token&quot;: token, &quot;en&quot;: row[&quot;en&quot;], &quot;zh&quot;: row[&quot;zh&quot;],
                    &quot;lcs_len&quot;: kk, &quot;lcs&quot;: sub
                })
        results.sort(key=lambda d: (-d[&quot;lcs_len&quot;], len(d[&quot;en&quot;])))
        return results[:k]

    def build_glossary_sentence_first(
        self, text: str, *, limit: int = 8, per_word_k: int = 2, min_lcs_len: int = 4,
    ) -&gt; Dict[str, str]:
        if len(self.lookup) == 0:
            return {}
        text_clean = <span class="ge">_clean_</span>for_glossary(text)
        tokens = self._TOKEN_RE.findall(text_clean)
        toks_lc = [t.lower() for t in tokens]
        n = len(toks_lc)
        covered = [False] * n
        glossary: Dict[str, str] = {}

        def _mark(i: int, j: int):
            for k in range(i, j): covered[k] = True

        win_max = min(n, getattr(self, &quot;max_soft_len&quot;, n))
        for w in range(win_max, 0, -1):
            if len(glossary) &gt;= limit: break
            for i in range(0, n - w + 1):
                if any(covered[k] for k in range(i, i + w)): continue
                phrase = &quot; &quot;.join(toks_lc[i:i + w])
                key = soft_norm(phrase)
                if key in self.soft_index:
                    en, zh = self.soft_index[key]
                    if en not in glossary:
                        glossary[en] = zh
                        _mark(i, i + w)
                        if len(glossary) &gt;= limit: break

        for idx, tok in enumerate(tokens):
            if len(glossary) &gt;= limit: break
            if covered[idx]: continue
            if len(tok) &lt; min_lcs_len: continue
            hits = self._topk_for_word(tok, k=per_word_k)
            for r in hits:
                if r[&quot;lcs_len&quot;] &gt;= min_lcs_len and r[&quot;en&quot;] not in glossary:
                    glossary[r[&quot;en&quot;]] = r[&quot;zh&quot;]
                    covered[idx] = True
                    if len(glossary) &gt;= limit: break
        return glossary

<span class="gh"># ================== 遮罩/還原 ==================</span>
<span class="ge">_MASK_</span>PAT = re.compile(
    r&#39;(&#39;
    r&#39;&lt;/?[A-Za-z][^&gt;]*&gt;&#39;
    r&#39;|&amp;lt;/?[A-Za-z][^&amp;]*?&amp;gt;&#39;
    r&#39;|%L\d+&#39;
    r&#39;|%\d+&#39;
    r&#39;|%n&#39;
    r&#39;|\{\d+\}&#39;
    r&#39;|&amp;(?:[A-Za-z]+|#\d+|#x[0-9A-Fa-f]+);&#39;
    r&#39;)&#39;,
    flags=re.IGNORECASE
)

def <span class="ge">_mask_</span>text(s: str) -&gt; Tuple[str, Dict[str, str]]:
    idx = 0
    mapping: Dict[str, str] = {}
    def _repl(m):
        nonlocal idx
        key = f&quot;⟦MASK{idx}⟧&quot;
        mapping[key] = m.group(0)
        idx += 1
        return key
    masked = <span class="ge">_MASK_</span>PAT.sub(_repl, s)
    return masked, mapping

def <span class="ge">_unmask_</span>text(s: str, mapping: Dict[str, str]) -&gt; str:
    for k, v in mapping.items():
        s = s.replace(k, v)
    return s

def <span class="ge">_et_</span>ready(s: str) -&gt; str:
    try:
        return html.unescape(s)
    except Exception:
        return s

<span class="gh"># ================== 判斷是否需要翻譯 ==================</span>
def needs_translation(en_text: Optional[str]) -&gt; bool:
    if not en_text or not en_text.strip():
        return False
    if re.fullmatch(r&quot;[\s\d\W%{}]+&quot;, en_text):
        return False
    return True

<span class="gh"># ================== OpenAI 呼叫（含重試） ==================</span>
def <span class="ge">_with_</span>retry(fn, *, tries=4, base=0.6, cap=4.0):
    last = None
    for t in range(tries):
        try:
            return fn()
        except Exception as e:
            last = e
            if t == tries - 1:
                break
            sleep = min(cap, base * (2 ** t)) * (0.8 + 0.4 * random.random())
            time.sleep(sleep)
    raise last if last else RuntimeError(&quot;未知錯誤&quot;)

def chatgpt_translate(masked_text: str, glossary: Dict[str, str], *, model: str, client: OpenAI) -&gt; str:
    glossary_str = &quot;\n&quot;.join([f&quot;- {en} -&gt; {zh}&quot; for en, zh in glossary.items()]) or &quot;（無）&quot;
    system_prompt = (
        &quot;你是台灣 GIS 軟體在地化譯者，請將英文翻為自然專業的繁體中文（台灣）。\n&quot;
        &quot;嚴格規則：\n&quot;
        &quot;1) ⟦MASKi⟧ 原樣保留且不可增刪；\n&quot;
        &quot;2) 不得輸出任何解釋或前後綴；只輸出譯文；\n&quot;
        &quot;3) Glossary 僅供參考，若不自然可忽略；\n&quot;
        &quot;4) 不要改動任何 HTML 標籤或 HTML 實體；&quot;
    )
    user_prompt = (
        f&quot;詞彙對照（僅供參考）：\n{glossary_str}\n\n&quot;
        f&quot;英文句子（含遮罩）：\n{masked_text}\n\n&quot;
        &quot;請直接輸出最終中文譯文：&quot;
    )
    def _call():
        resp = client.chat.completions.create(
            model=model,
            messages=[{&quot;role&quot;: &quot;system&quot;, &quot;content&quot;: system_prompt},
                      {&quot;role&quot;: &quot;user&quot;, &quot;content&quot;: user_prompt}],
            temperature=0.2,
            max_tokens=100,
        )
        return (resp.choices[0].message.content or &quot;&quot;).strip()
    zh = <span class="ge">_with_</span>retry(_call)
    for line in zh.splitlines():
        s = line.strip().strip(&quot;「」\&quot;&#39;&quot;)
        if s:
            return s
    return &quot;&quot;

def chatgpt_translate_batch(masked_texts: List[str], glossaries: List[Dict[str, str]], *, model: str, client: OpenAI) -&gt; List[str]:
    assert len(masked_texts) == len(glossaries), &quot;masked_texts / glossaries 長度不一致&quot;

    items = []
    for i, (t, g) in enumerate(zip(masked_texts, glossaries)):
        hints = [f&quot;{en} -&gt; {zh}&quot; for en, zh in g.items()]
        items.append({&quot;id&quot;: i, &quot;text&quot;: t, &quot;glossary&quot;: hints})

    system_prompt = (
        &quot;你是台灣 GIS 在地化譯者，將多個獨立英文片段翻為自然專業的繁體中文（台灣）。\n&quot;
        &quot;必守規則：\n&quot;
        &quot;• 保留並原樣輸出所有 ⟦MASK數字⟧ 片段；不可增刪或改動。\n&quot;
        &quot;• 不得輸出任何解釋、標題、程式碼框或多餘文字。\n&quot;
        &quot;• 請『只輸出』一個 JSON 陣列（字串陣列），長度必須與輸入 items 相同，且依原順序對應。\n&quot;
        &quot;• Glossary 僅供參考；若不自然可忽略。\n&quot;
        &quot;• 不要改動任何 HTML 標籤或 HTML 實體。&quot;
    )

    user_prompt = (
        &quot;請逐一翻譯下列 items。每個 item 格式如下：\n&quot;
        &quot;{ \&quot;id\&quot;: &lt;序號&gt;, \&quot;text\&quot;: \&quot;&lt;含遮罩的英文&gt;\&quot;, \&quot;glossary\&quot;: [\&quot;en -&gt; zh\&quot;, ...] }\n\n&quot;
        &quot;請『只輸出』一個 JSON 陣列，例如：\n&quot;
        &quot;[\&quot;譯文0\&quot;, \&quot;譯文1\&quot;, ...]\n\n&quot;
        f&quot;items = {json.dumps(items, ensure_ascii=False)}&quot;
    )

    def _call():
        resp = client.chat.completions.create(
            model=model,
            messages=[{&quot;role&quot;: &quot;system&quot;, &quot;content&quot;: system_prompt},
                      {&quot;role&quot;: &quot;user&quot;, &quot;content&quot;: user_prompt}],
            temperature=0.2,
            max_tokens=min(4096, 160 * max(4, len(masked_texts))),
        )
        return (resp.choices[0].message.content or &quot;&quot;).strip()

    raw = <span class="ge">_with_</span>retry(_call)

    def <span class="ge">_parse_</span>json_list(s: str) -&gt; List[str]:
        import json as _json
        try:
            arr = _json.loads(s)
            if isinstance(arr, list) and all(isinstance(x, str) for x in arr):
                return arr
        except Exception:
            pass
        lb = s.find(&#39;[&#39;)
        rb = s.rfind(&#39;]&#39;)
        if 0 &lt;= lb &lt; rb:
            chunk = s[lb:rb+1]
            arr = _json.loads(chunk)
            if isinstance(arr, list) and all(isinstance(x, str) for x in arr):
                return arr
        raise ValueError(&quot;模型輸出非純 JSON 字串陣列&quot;)

    arr = <span class="ge">_parse_</span>json_list(raw)
    if len(arr) != len(masked_texts):
        raise ValueError(f&quot;JSON 陣列長度不符，期待 {len(masked_texts)}，得到 {len(arr)}&quot;)
    return arr

<span class="gh"># ================== 翻譯輔助 ==================</span>
def translate_one(src_text: str, matcher: LCSMatcher, *, model: str, client: OpenAI) -&gt; str:
    glossary = matcher.build_glossary_sentence_first(src_text, limit=8, per_word_k=2, min_lcs_len=4)
    masked, mapping = <span class="ge">_mask_</span>text(src_text)
    zh_raw = chatgpt_translate(masked, glossary, model=model, client=client)
    if not zh_raw:
        return src_text
    zh = <span class="ge">_unmask_</span>text(zh_raw, mapping)
    if src_text.endswith(&quot;\n&quot;) and not zh.endswith(&quot;\n&quot;):
        zh += &quot;\n&quot;
    return zh

def translate_chunk(chunk_srcs: List[str], matcher: LCSMatcher, *, model: str, client: OpenAI) -&gt; List[str]:
    glossaries, masked_texts, mappings = [], [], []
    for s in chunk_srcs:
        g = matcher.build_glossary_sentence_first(s, limit=8, per_word_k=2, min_lcs_len=4)
        glossaries.append(g)
        masked, mp = <span class="ge">_mask_</span>text(s)
        masked_texts.append(masked)
        mappings.append(mp)
    try:
        zh_list = chatgpt_translate_batch(masked_texts, glossaries, model=model, client=client)
    except Exception:
        zh_list = []
        for s in chunk_srcs:
            try:
                zh_list.append(translate_one(s, matcher, model=model, client=client))
            except Exception:
                zh_list.append(s)
    return [<span class="ge">_et_</span>ready(_unmask_text(z, mp)) for z, mp in zip(zh_list, mappings)]

<span class="gh"># ================== 主流程（支援 widgets 進度） ==================</span>
def process_ts_openai(input_ts: str, output_ts: str, matcher: LCSMatcher, *, 
                      openai_api_key: str, openai_model: str = &quot;gpt-4.1-mini&quot;,
                      batch_size: int = 16, concurrency: int = 4,
                      on_total: Optional[Callable[[int], None]] = None,
                      on_progress: Optional[Callable[[int], None]] = None,
                      on_log: Optional[Callable[[str], None]] = None):
    &quot;&quot;&quot;
    on_total(total)   ：回報 unique 原文數
    on_progress(delta)：每完成 delta 筆 unique 原文時呼叫
    on_log(msg)       ：即時訊息輸出
    &quot;&quot;&quot;
    if on_log: on_log(f&quot;開始處理：{input_ts}&quot;)
    client = OpenAI(api_key=openai_api_key)
    # 備份
    shutil.copyfile(input_ts, f&quot;{input_ts}.bak&quot;)
    raw_xml = open(input_ts, &quot;r&quot;, encoding=&quot;utf-8&quot;).read()
    doctype = <span class="ge">_read_</span>doctype(raw_xml)

    tree = ET.ElementTree(ET.fromstring(raw_xml))
    root = tree.getroot()

    messages = root.findall(&quot;.//message&quot;)
    tasks = []
    for m in messages:
        src_el = m.find(&quot;source&quot;)
        if src_el is None or src_el.text is None:
            continue
        if needs_translation(src_el.text):
            tasks.append((m, src_el.text, m.get(&quot;numerus&quot;) == &quot;yes&quot;))

    total_msg = len(messages)
    need_cnt = len(tasks)
    if on_log: on_log(f&quot;🔍 原始檔共 {total_msg} 筆 message，需翻譯 {need_cnt} 筆&quot;)

    if not tasks:
        xml_bytes = ET.tostring(root, encoding=&quot;utf-8&quot;)
        with open(output_ts, &quot;wb&quot;) as f:
            f.write(b&#39;&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#39;)
            if doctype:
                f.write((&quot;\n&quot; + doctype + &quot;\n&quot;).encode(&quot;utf-8&quot;))
            f.write(xml_bytes)
        if on_log: on_log(f&quot;✅ 無需翻譯，輸出 -&gt; {output_ts}&quot;)
        return

    # 去重
    idx_map: Dict[str, int] = {}
    uniq_srcs: List[str] = []
    task_uid: List[int] = []
    for <span class="ge">_m, src, _</span>num in tasks:
        if src not in idx_map:
            idx_map[src] = len(uniq_srcs)
            uniq_srcs.append(src)
        task_uid.append(idx_map[src])

    if on_total: on_total(len(uniq_srcs))

    uniq_zh = [&quot;&quot;] * len(uniq_srcs)
    chunks = [uniq_srcs[i:i+batch_size] for i in range(0, len(uniq_srcs), batch_size)]

    pbar = tqdm(total=len(uniq_srcs), desc=&quot;翻譯唯一字串&quot;, unit=&quot;筆&quot;)
    with ThreadPoolExecutor(max_workers=concurrency) as ex:
        futures = {ex.submit(translate_chunk, ch, matcher, model=openai_model, client=client): (idx, ch) 
                   for idx, ch in enumerate(chunks)}
        for fut in as_completed(futures):
            idx, ch = futures[fut]
            base = idx * batch_size
            try:
                result = fut.result()
            except Exception as e:
                if on_log: on_log(f&quot;[警告] 批次失敗（降級逐筆）：{e}&quot;)
                result = [translate_one(s, matcher, model=openai_model, client=client) for s in ch]
            for j, zh in enumerate(result):
                if base + j &lt; len(uniq_zh):
                    uniq_zh[base + j] = zh
            pbar.update(len(ch))
            if on_progress: on_progress(len(ch))
    pbar.close()

    # 回填
    for (m, <span class="ge">_src_</span>text, is_numerus), uid in zip(tasks, task_uid):
        trans_el = m.find(&quot;translation&quot;)
        if trans_el is None:
            trans_el = ET.SubElement(m, &quot;translation&quot;)
        zh = uniq_zh[uid] or <span class="ge">_src_</span>text
        if is_numerus:
            forms = trans_el.findall(&quot;numerusform&quot;)
            if not forms:
                forms = [ET.SubElement(trans_el, &quot;numerusform&quot;)]
            for f in forms:
                f.text = zh
        else:
            trans_el.text = zh
        trans_el.attrib.pop(&quot;type&quot;, None)

    xml_bytes = ET.tostring(root, encoding=&quot;utf-8&quot;)
    with open(output_ts, &quot;wb&quot;) as f:
        f.write(b&#39;&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#39;)
        if doctype:
            f.write((&quot;\n&quot; + doctype + &quot;\n&quot;).encode(&quot;utf-8&quot;))
        f.write(xml_bytes)

    if on_log: on_log(f&quot;✅ 完成翻譯 {len(tasks)} 筆（唯一 {len(uniq_srcs)} 筆），輸出 -&gt; {output_ts}&quot;)

import io, os, pathlib
import ipywidgets as W
from IPython.display import display, FileLink

<span class="gh"># --- Widgets ---</span>
api_box   = W.Password(description=&quot;API Key&quot;, placeholder=&quot;sk-...&quot;)
model_box = W.Text(value=&quot;gpt-4.1-mini&quot;, description=&quot;Model&quot;)
batch_box = W.BoundedIntText(value=16, min=1, max=64, step=1, description=&quot;Batch&quot;)
conc_box  = W.BoundedIntText(value=4, min=1, max=16, step=1, description=&quot;Concurrency&quot;)

upload_ts = W.FileUpload(accept=&quot;.ts&quot;, multiple=False, description=&quot;上傳 .ts&quot;)
start_btn = W.Button(description=&quot;開始&quot;, button_style=&quot;success&quot;)
progress  = W.IntProgress(value=0, min=0, max=1, description=&quot;進度&quot;)
log_out   = W.Output(layout={&quot;border&quot;:&quot;1px solid <span class="ni">#ddd</span>&quot;})

controls = W.VBox([api_box, model_box, W.HBox([batch_box, conc_box]), upload_ts, start_btn, progress, log_out])
display(controls)

workdir = pathlib.Path(&quot;./work&quot;)
workdir.mkdir(exist_ok=True)

def _log(msg):
    with log_out:
        print(msg)

def <span class="ge">_on_</span>total(total):
    progress.max = max(1, int(total))
    progress.value = 0
    progress.description = f&quot;進度 (共 {total})&quot;

def <span class="ge">_on_</span>progress(delta):
    progress.value = min(progress.max, progress.value + int(delta))

def <span class="ge">_save_</span>upload(uploader: W.FileUpload, dst_path: pathlib.Path) -&gt; bool:
    if not uploader.value:
        _log(&quot;請先上傳 .ts 檔&quot;)
        return False
    item = list(uploader.value.values())[0]
    data = item[&quot;content&quot;]
    dst_path.write_bytes(data)
    <span class="ge">_log(f&quot;已儲存：{dst_</span>path}&quot;)
    return True

def <span class="ge">_on_</span>start(_btn):
    log_out.clear_output()
    if not api_box.value.strip():
        _log(&quot;請輸入 OpenAI API Key&quot;)
        return
    src = workdir / &quot;input.ts&quot;
    out = workdir / &quot;output_zh-Hant.ts&quot;
    if not <span class="ge">_save_</span>upload(upload_ts, src):
        return
    try:
        df_lookup = load_lookup_from_ods(&quot;data&quot;)  # 若無 ODS 也會正常回傳空表
        matcher = LCSMatcher(df_lookup, min_token_len=4, min_lcs_len=4)
        process_ts_openai(
            str(src), str(out), matcher,
            openai_api_key=api_box.value.strip(),
            openai_model=model_box.value.strip() or &quot;gpt-4.1-mini&quot;,
            batch_size=int(batch_box.value),
            concurrency=int(conc_box.value),
            on_total=_on_total,
            on_progress=_on_progress,
            on_log=_log,
        )
        _log(&quot;完成。&quot;)
        display(FileLink(out, result_html_prefix=&quot;下載結果：&quot;))
    except Exception as e:
        _log(f&quot;[錯誤] {e}&quot;)

start_btn.on_click(_on_start)
</pre></div>
</div>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "wendy062644/2025-summer-intern-project-2",
            ref: "main",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            name: "python3",
            path: "./pages"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

                </article>
              

              
              
              
              
                <footer class="prev-next-footer d-print-none">
                  
<div class="prev-next-area">
    <a class="left-prev"
       href="../intro.html"
       title="previous page">
      <i class="fa-solid fa-angle-left"></i>
      <div class="prev-next-info">
        <p class="prev-next-subtitle">previous</p>
        <p class="prev-next-title">Welcome to your Jupyter Book</p>
      </div>
    </a>
</div>
                </footer>
              
            </div>
            
            
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
By The Jupyter Book Community
</p>

  </div>
  
  <div class="footer-item">
    

  <p class="copyright">
    
      © Copyright 2023.
      <br/>
    
  </p>

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b"></script>
<script src="../_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>